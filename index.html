<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Torneo Pro - Control de Gesti√≥n</title>
    <style>
        :root { --primary: #1e40af; --secondary: #10b981; --accent: #f59e0b; --danger: #dc2626; --warning: #f59e0b; --bg: #f1f5f9; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); margin: 0; color: #1e293b; padding-bottom: 50px; }
        nav { background: #1e293b; display: flex; justify-content: center; position: sticky; top: 0; z-index: 1000; box-shadow: 0 2px 10px rgba(0,0,0,0.2); }
        .tab-btn { background: none; border: none; color: #94a3b8; padding: 15px 15px; cursor: pointer; font-weight: 600; font-size: 0.8rem; border-bottom: 3px solid transparent; }
        .tab-btn.active { color: white; border-bottom: 3px solid var(--secondary); }
        .container { max-width: 800px; margin: 20px auto; padding: 0 15px; }
        .card { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.05); display: none; }
        .card.active { display: block; }
        textarea { width: 100%; height: 120px; padding: 10px; border-radius: 8px; border: 1px solid #cbd5e1; font-family: monospace; box-sizing: border-box; }
        .grid-inputs { display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; margin-bottom: 15px; }
        input, select, button { padding: 10px; border: 1px solid #cbd5e1; border-radius: 8px; }
        .btn { cursor: pointer; font-weight: bold; border: none; padding: 10px 20px; border-radius: 8px; transition: 0.2s; }
        .btn:active { transform: scale(0.98); }
        .btn-add { background: var(--primary); color: white; }
        .btn-gen { background: var(--secondary); color: white; width: 100%; font-size: 1.1rem; margin-top: 20px; }
        .btn-warning { background: var(--warning); color: white; flex: 1; }
        .btn-danger { background: var(--danger); color: white; flex: 1; }
        .action-group { display: flex; gap: 10px; margin-top: 20px; }
        .match-card { border: 1px solid #e2e8f0; border-radius: 8px; margin-bottom: 15px; background: white; }
        .match-header { background: #f8fafc; padding: 8px 15px; display: flex; justify-content: space-between; font-size: 0.8rem; border-bottom: 1px solid #e2e8f0; font-weight: bold; }
        .match-body { padding: 15px; display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 10px; text-align: center; }
        .score-input { width: 45px; text-align: center; font-size: 1.2rem; font-weight: bold; border: 2px solid #3b82f6; border-radius: 4px; }
        .badge { padding: 2px 6px; border-radius: 4px; color: white; font-size: 0.7rem; }
        .bg-cancha { background: #3b82f6; }
        .bg-hora { background: #64748b; }
        .player-list-item { display: flex; justify-content: space-between; padding: 8px; border-bottom: 1px solid #eee; font-size: 0.9rem; }
        .avg-label { font-size: 0.7rem; color: #64748b; margin-top: 4px; display: block; }
    </style>
    <script>
        window.players = [];
        window.courts = [];
        window.matches = [];
    </script>
    <script type="module">

import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getFirestore, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyBfsVZKiSplO_m2-JDITvHapJnvW_3idDE",
  authDomain: "padel-americano-sansebastian.firebaseapp.com",
  projectId: "padel-americano-sansebastian",
  storageBucket: "padel-americano-sansebastian.firebasestorage.app",
  messagingSenderId: "211505574132",
  appId: "1:211505574132:web:d9a00441235e87bd4deea1"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

        
// üëá Hacemos global lo que necesit√°s
window.saveToFirebase = async function(players, courts, matches) {

    const playersToSave = players.map(p => ({
        ...p,
        historyPartners: Array.from(p.historyPartners || []),
        historyRivals: Array.from(p.historyRivals || [])
    }));

    await setDoc(
        doc(db, "torneos", "americano1"),
        { players: playersToSave, courts, matches }
    );
};

document.addEventListener("DOMContentLoaded", () => {

    onSnapshot(doc(db, "torneos", "americano1"), (docSnap) => {

        if (!docSnap.exists()) return;

        const data = docSnap.data();

        players = data.players || [];
        courts = data.courts || [];
        matches = data.matches || [];

        normalizePlayers();
        renderPlayers();
        renderCourts();
        renderFixture();
    });

});

</script>


</head>
<body>

    <nav>
        <button class="tab-btn active" onclick="openTab(event, 'jugadores')">JUGADORES</button>
        <button class="tab-btn" onclick="openTab(event, 'canchas')">CANCHAS</button>
        <button class="tab-btn" onclick="openTab(event, 'fixture')">FIXTURE</button>
        <button class="tab-btn" onclick="openTab(event, 'posiciones')">POSICIONES</button>
    </nav>

    <div class="container">
        <div id="jugadores" class="card active">
            <h3>Carga Masiva</h3>
            <textarea id="bulkPlayers" placeholder="Nombre, Categoria (Ej: Juan, 7)"></textarea>
            <button class="btn btn-add" style="width:100%; margin-top:10px" onclick="importPlayers()">Importar Lista</button>
            <h4 style="margin-top:20px">Inscriptos: <span id="pCount">0</span></h4>
            <div id="playerList"></div>
            
            <div class="action-group">
                <button class="btn btn-warning" onclick="resetFixtureOnly()">üîÑ Rehacer Fixture</button>
                <button class="btn btn-danger" onclick="resetAllPlayersAndMatches()">üóëÔ∏è Borrar Todo</button>
            </div>
            <p style="font-size: 0.7rem; color: #64748b; margin-top: 10px; text-align: center;">
                *Las canchas y horarios se mantienen guardados siempre.
            </p>
        </div>

        <div id="canchas" class="card">
            <h3>Canchas y Horarios</h3>
            <div class="grid-inputs">
                <input type="text" id="cName" placeholder="Cancha 1">
                <input type="time" id="cTime" value="18:00">
                <button class="btn btn-add" onclick="addCourt()">A√±adir</button>
            </div>
            <div id="courtList"></div>
            <button class="btn btn-gen" onclick="generateTournament()">GENERAR FIXTURE EQUILIBRADO</button>
            <button class="btn btn-warning" 
                onclick="regenerateFutureMatches()"
                style="width:100%; margin-bottom:15px">
                üîÑ Recalcular partidos pendientes
            </button>

        </div>

        <div id="fixture" class="card">
            <h3>Cronograma de Partidos</h3>
            <div id="fixtureContent"></div>
        </div>

        <div id="posiciones" class="card">
            <h3>Ranking Individual</h3>
            <div id="rankingContent"></div>
        </div>
    </div>

    <script>

function save() {
    saveToFirebase(players, courts, matches);
}

        function openTab(evt, name) {
            document.querySelectorAll('.card').forEach(c => c.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(name).classList.add('active');
            if(evt) evt.currentTarget.classList.add('active');
            if(name === 'posiciones') calculateRanking();
            if(name === 'fixture') renderFixture();
        }

     function importPlayers() {
    const lines = document.getElementById('bulkPlayers').value.split('\n');

    lines.forEach(line => {
        const parts = line.split(',');
        if(parts.length >= 2) {
            const name = parts[0].trim();
            const cat = parseInt(parts[1].trim());

            if(name && !isNaN(cat)) {
                players.push({ 
                    id: Math.random().toString(36).substr(2, 9), 
                    name,
                    cat,
                    startTime: "18:00",
                    endTime: "23:59",   // üî• NUEVO
                    matchesPlayed: 0,
                    lastTurn: -1 
                });
            }
        }
    });

    document.getElementById('bulkPlayers').value = '';
    save(); 
    renderPlayers();
}



 function renderPlayers() {

    document.getElementById('pCount').innerText = players.length;

    document.getElementById('playerList').innerHTML =
        players.map((p, i) => `
            <div class="player-list-item">
                <span>
                    ${p.name} <strong>(Cat ${p.cat}¬∞)</strong><br>

                    <small>Ingreso:</small>
                    <input type="time"
                        value="${p.startTime || '18:00'}"
                        onchange="updateStartTime(${i}, this.value)"
                        style="font-size:0.75rem;">

                    <small>Salida:</small>
                    <input type="time"
                        value="${p.endTime || '23:59'}"
                        onchange="updateEndTime(${i}, this.value)"
                        style="font-size:0.75rem;">
                </span>

                <button onclick="removePlayer(${i})"
                    style="color:red;background:none;border:none;cursor:pointer">‚úï</button>
            </div>
        `).join('');
}


function updateStartTime(i, value) {
    players[i].startTime = value;
    save();
}

function updateEndTime(i, value) {
    players[i].endTime = value;
    save();
}

        function removePlayer(i) { players.splice(i, 1); save(); renderPlayers(); }

        // --- NUEVAS FUNCIONES DE LIMPIEZA ---
        function resetFixtureOnly() {
            if(confirm("¬øQuieres borrar solo el fixture? Mantendr√°s la lista de jugadores intacta para volver a sortear.")) {
                matches = [];
                save();
                renderFixture();
                alert("Fixture borrado. Puedes ir a la solapa de Canchas y generarlo de nuevo.");
            }
        }

        function resetAllPlayersAndMatches() {
            if(confirm("ATENCI√ìN: Se borrar√°n todos los jugadores y el fixture actual. ¬øDeseas continuar?")) {
                players = [];
                matches = [];
                save();
                renderPlayers();
                renderFixture();
            }
        }

        // --- L√ìGICA DE CANCHAS ---
        function addCourt() {
            const name = document.getElementById('cName').value;
            const time = document.getElementById('cTime').value;
            if(name && time) {
                courts.push({ id: Date.now(), name, startTime: time });
                save(); renderCourts();
            }
        }

        function renderCourts() {
            document.getElementById('courtList').innerHTML = courts.map((c, i) => `
                <div class="player-list-item">
                    <span><span class="badge bg-cancha">${c.name}</span> Inicio: ${c.startTime} hs</span>
                    <button onclick="removeCourt(${i})" style="color:red; background:none; border:none; cursor:pointer">‚úï</button>
                </div>
            `).join('');
        }
        function removeCourt(i) { courts.splice(i,1); save(); renderCourts(); }

  function generateTournament(startFromTime = 0, isRegeneration = false) {

    normalizePlayers(); // üëà AGREGAR ESTO

    console.log("=== GENERANDO TORNEO ===");

    const timeline = generateTimeline(); // Debe devolver array con:
    // { time, court, timeMins, sortKey }

    for (let slot of timeline) {

        if (slot.sortKey < startFromTime)
            continue;

        console.log("Evaluando slot:", slot.time, slot.court);

        // 1Ô∏è‚É£ Filtrar jugadores disponibles en este horario
        let disponibles = players.filter(p => {

            if (p.endTime) {
                const [eh, em] = p.endTime.split(':').map(Number);
                const endMins = eh * 60 + em;
                if (slot.timeMins > endMins)
                    return false;
            }

            if (p.startTime) {
                const [sh, sm] = p.startTime.split(':').map(Number);
                const startMins = sh * 60 + sm;
                if (slot.timeMins < startMins)
                    return false;
            }

            return true;
        });

        if (disponibles.length < 4) {
            console.log("No hay suficientes jugadores.");
            continue;
        }

        // 2Ô∏è‚É£ ORDEN INTELIGENTE POR RATIO REAL
        disponibles.sort((a, b) => {

            function calcularRatio(jugador) {

                let ingresoMins = 0;

                if (jugador.startTime) {
                    let [h, m] = jugador.startTime.split(':').map(Number);
                    ingresoMins = h * 60 + m;
                }

                let turnosDisponibles =
                    timeline.filter(t =>
                        t.timeMins >= ingresoMins &&
                        t.timeMins <= slot.timeMins
                    ).length;

                if (turnosDisponibles === 0) return 0;

                return jugador.matchesPlayed / turnosDisponibles;
            }

            const ratioA = calcularRatio(a);
            const ratioB = calcularRatio(b);

            if (ratioA !== ratioB)
                return ratioA - ratioB;

            return a.lastTurn - b.lastTurn;
        });

        const match = findValidMatch(disponibles);

        if (!match) {
            console.log("No se pudo armar partido v√°lido.");
            continue;
        }

        const newMatch = {
            id: matches.length + 1,
            t1: match.team1,
            t2: match.team2,
            time: slot.time,
            court: slot.court,
            sortKey: slot.sortKey,
            s1: null,
            s2: null
        };

        matches.push(newMatch);

        // 3Ô∏è‚É£ Actualizar estad√≠sticas
        [...match.team1, ...match.team2].forEach(p => {

            p.matchesPlayed++;
            p.lastTurn = slot.sortKey;

        });

        // 4Ô∏è‚É£ Guardar historial
        registerHistory(match.team1, match.team2);

        console.log("Partido generado:", newMatch.id);
    }

    save();
}


function findValidMatch(playersList) {

    for (let i = 0; i < playersList.length; i++) {
        for (let j = i + 1; j < playersList.length; j++) {

            const p1 = playersList[i];
            const p2 = playersList[j];

            if (p1.historyPartners.has(p2.id))
                continue;

            for (let k = 0; k < playersList.length; k++) {
                for (let l = k + 1; l < playersList.length; l++) {

                    const p3 = playersList[k];
                    const p4 = playersList[l];

                    if (
                        p1.id === p3.id ||
                        p1.id === p4.id ||
                        p2.id === p3.id ||
                        p2.id === p4.id
                    )
                        continue;

                    if (p3.historyPartners.has(p4.id))
                        continue;

                    const conflicto =
                        p1.historyRivals.has(p3.id) ||
                        p1.historyRivals.has(p4.id) ||
                        p2.historyRivals.has(p3.id) ||
                        p2.historyRivals.has(p4.id);

                    if (conflicto)
                        continue;

                    return {
                        team1: [p1, p2],
                        team2: [p3, p4]
                    };
                }
            }
        }
    }

    return null;
}

function registerHistory(team1, team2) {

    const realTeam1 = team1.map(p => players.find(x => x.id === p.id));
    const realTeam2 = team2.map(p => players.find(x => x.id === p.id));

    if (realTeam1.includes(undefined) || realTeam2.includes(undefined)) {
        console.error("Jugador no encontrado en players");
        return;
    }

    // Compa√±eros
    realTeam1[0].historyPartners.add(realTeam1[1].id);
    realTeam1[1].historyPartners.add(realTeam1[0].id);

    realTeam2[0].historyPartners.add(realTeam2[1].id);
    realTeam2[1].historyPartners.add(realTeam2[0].id);

    // Rivales
    for (let a of realTeam1) {
        for (let b of realTeam2) {
            a.historyRivals.add(b.id);
            b.historyRivals.add(a.id);
        }
    }
}


function normalizePlayers() {

    players.forEach(p => {

        // ---- historyPartners ----
        if (Array.isArray(p.historyPartners)) {
            p.historyPartners = new Set(p.historyPartners);
        } else {
            p.historyPartners = new Set();
        }

        // ---- historyRivals ----
        if (Array.isArray(p.historyRivals)) {
            p.historyRivals = new Set(p.historyRivals);
        } else {
            p.historyRivals = new Set();
        }

        // ---- stats ----
        if (typeof p.matchesPlayed !== "number")
            p.matchesPlayed = 0;

        if (typeof p.lastTurn !== "number")
            p.lastTurn = -1;
    });
}

        
function regenerateFutureMatches() {

    normalizePlayers(); // üëà AGREGAR ESTO

    if (!confirm("Se recalcular√°n SOLO los partidos no jugados respetando historial. ¬øContinuar?"))
        return;

    const playedMatches =
        matches.filter(m => m.s1 !== null && m.s2 !== null);

    const pendingMatches =
        matches.filter(m => m.s1 === null && m.s2 === null);

    if (pendingMatches.length === 0) {
        alert("No hay partidos pendientes.");
        return;
    }

    let startFromTime = 0;

    if (playedMatches.length > 0) {
        const lastPlayed = playedMatches[playedMatches.length - 1];
        startFromTime = lastPlayed.sortKey;
    }

    matches = [...playedMatches];

    // RESET TOTAL
    players.forEach(p => {
        p.matchesPlayed = 0;
        p.lastTurn = -1;
        p.historyPartners = new Set();
        p.historyRivals = new Set();
    });

    // RECONSTRUIR DESDE HISTORIAL REAL
    playedMatches.forEach(m => {

        const team1 = m.t1;
        const team2 = m.t2;

        registerHistory(team1, team2);

        [...team1, ...team2].forEach(p => {

            const player = players.find(x => x.id === p.id);

            if (player) {
                player.matchesPlayed++;
                player.lastTurn = m.sortKey;
            }

        });
    });

    console.log("Historial reconstruido correctamente");

    generateTournament(startFromTime, true);

    save();
}






function deleteMatch(index) {

    const m = matches[index];

    if (m.s1 !== null && m.s2 !== null) {
        alert("No se puede borrar un partido ya jugado.");
        return;
    }

    matches.splice(index, 1);
    save();
    renderFixture();
}
  
function generateTimeline() {

    const timeline = [];

    courts.forEach(c => {

        const [h, m] = c.startTime.split(':').map(Number);
        const baseMins = h * 60 + m;

        // 3 partidos de 20' dentro de la reserva de 60'
        for (let i = 0; i < 3; i++) {

            const slotMins = baseMins + (i * 20);

            const hour = Math.floor(slotMins / 60);
            const mins = slotMins % 60;

            const timeStr =
                String(hour).padStart(2, '0') + ":" +
                String(mins).padStart(2, '0');

            timeline.push({
                courtId: c.id,
                court: c.name,
                time: timeStr,
                timeMins: slotMins,
                sortKey: slotMins
            });
        }
    });

    return timeline.sort((a, b) => a.sortKey - b.sortKey);
}

        
        function renderFixture() {
            const container = document.getElementById('fixtureContent');
            if(matches.length === 0) { container.innerHTML = "<p style='text-align:center; color:#94a3b8;'>No hay partidos generados. Ve a 'Canchas' y presiona el bot√≥n verde.</p>"; return; }
            container.innerHTML = matches.map((m, idx) => `
                <div class="match-card">
                    <div class="match-header">
                        <span>PARTIDO #${m.id}</span>
                        <span><span class="badge bg-hora">${m.time} HS</span> <span class="badge bg-cancha">${m.court}</span></span>
                    </div>
                    <div class="match-body">
                        <div><strong>${m.t1[0].name} (${m.t1[0].cat})<br>${m.t1[1].name} (${m.t1[1].cat})</strong></div>
                        <div>
                            <input type="number" class="score-input" value="${m.s1 !== null ? m.s1 : ''}" onchange="updateScore(${idx}, 1, this.value)">
                            <input type="number" class="score-input" value="${m.s2 !== null ? m.s2 : ''}" onchange="updateScore(${idx}, 2, this.value)">
                        </div>
                        <div><strong>${m.t2[0].name} (${m.t2[0].cat})<br>${m.t2[1].name} (${m.t2[1].cat})</strong></div>
                    </div>
                </div>
            `).join('');
        }

        function updateScore(idx, team, val) {
            const v = val === "" ? null : parseInt(val);
            if(team === 1) matches[idx].s1 = v; else matches[idx].s2 = v;
            save();
        }

        function calculateRanking() {
            let s = {};
            players.forEach(p => s[p.id] = { name: p.name, wins: 0, games: 0, played: 0 });
            matches.forEach(m => {
                if(m.s1 === null || m.s2 === null) return;
                [...m.t1, ...m.t2].forEach(p => { if(s[p.id]) s[p.id].played++; });
                m.t1.forEach(p => s[p.id].games += m.s1);
                m.t2.forEach(p => s[p.id].games += m.s2);
                if(m.s1 > m.s2) m.t1.forEach(p => s[p.id].wins++);
                else if(m.s2 > m.s1) m.t2.forEach(p => s[p.id].wins++);
            });
            const sorted = Object.values(s).sort((a,b) => b.wins - a.wins || (b.wins/b.played) - (a.wins/a.played) || b.games - a.games);
            document.getElementById('rankingContent').innerHTML = sorted.map((p, i) => `
                <div class="player-list-item">
                    <span><strong>${i+1}. ${p.name}</strong></span>
                    <span>${p.wins} G | ${p.games} Pts | ${p.played} PJ</span>
                </div>
            `).join('');
        }

        renderPlayers(); renderCourts(); renderFixture();

     

    </script>
</body>
</html>
