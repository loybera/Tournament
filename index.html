<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Torneo Pro - Control de Gesti√≥n</title>
    <style>
        :root { --primary: #1e40af; --secondary: #10b981; --accent: #f59e0b; --danger: #dc2626; --warning: #f59e0b; --bg: #f1f5f9; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); margin: 0; color: #1e293b; padding-bottom: 50px; }
        nav { background: #1e293b; display: flex; justify-content: center; position: sticky; top: 0; z-index: 1000; box-shadow: 0 2px 10px rgba(0,0,0,0.2); }
        .tab-btn { background: none; border: none; color: #94a3b8; padding: 15px 15px; cursor: pointer; font-weight: 600; font-size: 0.8rem; border-bottom: 3px solid transparent; }
        .tab-btn.active { color: white; border-bottom: 3px solid var(--secondary); }
        .container { max-width: 800px; margin: 20px auto; padding: 0 15px; }
        .card { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.05); display: none; }
        .card.active { display: block; }
        textarea { width: 100%; height: 120px; padding: 10px; border-radius: 8px; border: 1px solid #cbd5e1; font-family: monospace; box-sizing: border-box; }
        .grid-inputs { display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; margin-bottom: 15px; }
        input, select, button { padding: 10px; border: 1px solid #cbd5e1; border-radius: 8px; }
        .btn { cursor: pointer; font-weight: bold; border: none; padding: 10px 20px; border-radius: 8px; transition: 0.2s; }
        .btn:active { transform: scale(0.98); }
        .btn-add { background: var(--primary); color: white; }
        .btn-gen { background: var(--secondary); color: white; width: 100%; font-size: 1.1rem; margin-top: 20px; }
        .btn-warning { background: var(--warning); color: white; flex: 1; }
        .btn-danger { background: var(--danger); color: white; flex: 1; }
        .action-group { display: flex; gap: 10px; margin-top: 20px; }
        .match-card { border: 1px solid #e2e8f0; border-radius: 8px; margin-bottom: 15px; background: white; }
        .match-header { background: #f8fafc; padding: 8px 15px; display: flex; justify-content: space-between; font-size: 0.8rem; border-bottom: 1px solid #e2e8f0; font-weight: bold; }
.match-body {
    padding: 15px;
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    align-items: center;
    gap: 10px;
    text-align: center;
}

/* üì± MOBILE */
@media (max-width: 600px) {

    .container {
        padding: 0 10px;
    }

    .match-body {
        grid-template-columns: 1fr;
        gap: 15px;
    }

    .score-input {
        width: 60px;
        font-size: 1.4rem;
    }

    .match-header {
        font-size: 0.7rem;
        flex-direction: column;
        align-items: flex-start;
        gap: 5px;
    }

    .player-list-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 5px;
    }

    .tab-btn {
        font-size: 0.7rem;
        padding: 12px 8px;
    }
}

        .score-input {
    width: 55px;
    height: 45px;
}

        .badge { padding: 2px 6px; border-radius: 4px; color: white; font-size: 0.7rem; }
        .bg-cancha { background: #3b82f6; }
        .bg-hora { background: #64748b; }
        .player-list-item { display: flex; justify-content: space-between; padding: 8px; border-bottom: 1px solid #eee; font-size: 0.9rem; }
        .avg-label { font-size: 0.7rem; color: #64748b; margin-top: 4px; display: block; }

        /* ----- PLAYER LIST MOBILE IMPROVEMENT ----- */

.player-list-item {
    background: #ffffff;
    border-radius: 10px;
    padding: 10px;
    margin-bottom: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

/* Desktop mantiene horizontal */
.player-list-item span {
    display: block;
}

/* üì± MOBILE */
@media (max-width: 600px) {

    .player-list-item {
        padding: 12px;
    }

    .player-list-item strong {
        font-size: 1rem;
    }

    .player-list-item small {
        display: block;
        margin-top: 6px;
        font-size: 0.75rem;
        color: #64748b;
    }

    .player-list-item input[type="time"] {
        width: 100%;
        margin-top: 4px;
        font-size: 0.9rem;
        padding: 8px;
    }

    .player-list-item button {
        align-self: flex-end;
        margin-top: 10px;
        font-size: 1.1rem;
        padding: 6px 12px;
        border-radius: 6px;
        background: #fee2e2;
    }
}

    </style>
    <script>
        window.players = [];
        window.courts = [];
        window.matches = [];
        window.isAdmin = false;

    </script>
    <script type="module">

import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getFirestore, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyBfsVZKiSplO_m2-JDITvHapJnvW_3idDE",
  authDomain: "padel-americano-sansebastian.firebaseapp.com",
  projectId: "padel-americano-sansebastian",
  storageBucket: "padel-americano-sansebastian.firebasestorage.app",
  messagingSenderId: "211505574132",
  appId: "1:211505574132:web:d9a00441235e87bd4deea1"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

        
// üëá Hacemos global lo que necesit√°s
window.saveToFirebase = async function(players, courts, matches) {

      const playersToSave = players.map(p => ({
    ...p,
    historyPartners: Array.from(p.historyPartners || []),
    historyRivals: Array.from(p.historyRivals || [])
  }));

  await setDoc(doc(db, "torneos", "americano1"), {
    players: playersToSave,
    courts,
    matches
  });
};

document.addEventListener("DOMContentLoaded", () => {

    onSnapshot(doc(db, "torneos", "americano1"), (docSnap) => {

        if (!docSnap.exists()) return;

        const data = docSnap.data();

        players = (data.players || []).map(p => ({
          ...p,
          historyPartners: new Set(p.historyPartners || []),
          historyRivals: new Set(p.historyRivals || [])
        }));        courts = data.courts || [];
        matches = data.matches || [];

        normalizePlayers();
        renderPlayers();
        renderCourts();
        renderFixture();
    });

});

</script>


</head>
<body>

    <nav>
        <button class="tab-btn active" onclick="openTab(event, 'jugadores')">JUGADORES</button>
        <button class="tab-btn" onclick="openTab(event, 'canchas')">CANCHAS</button>
        <button class="tab-btn" onclick="openTab(event, 'fixture')">FIXTURE</button>
        <button class="tab-btn" onclick="openTab(event, 'posiciones')">POSICIONES</button>
        <button class="tab-btn" onclick="openTab(event, 'admin')">ADMIN</button>

    </nav>

    <div class="container">
        <div id="jugadores" class="card active">
            <div id="bulkSection">
                <h3>Carga Masiva</h3>
                <textarea id="bulkPlayers"
                    placeholder="Nombre, Categoria (Ej: Juan, 7)">
                </textarea>
                <button class="btn btn-add"
                    style="width:100%; margin-top:10px"
                    onclick="importPlayers()">
                    Importar Lista
                </button>
            </div>


            <h4 style="margin-top:20px">Inscriptos: <span id="pCount">0</span></h4>
            <div id="playerList"></div>
            
            <div class="action-group">
                <button class="btn btn-warning" onclick="resetFixtureOnly()">üîÑ Rehacer Fixture</button>
                <button class="btn btn-danger" onclick="resetAllPlayersAndMatches()">üóëÔ∏è Borrar Todo</button>
            </div>
            <p style="font-size: 0.7rem; color: #64748b; margin-top: 10px; text-align: center;">
                *Las canchas y horarios se mantienen guardados siempre.
            </p>
        </div>

        <div id="canchas" class="card">
            <h3>Canchas y Horarios</h3>
            <div class="grid-inputs">
                <input type="text" id="cName" placeholder="Cancha 1">
                <input type="time" id="cTime" value="18:00">
                <button class="btn btn-add" onclick="addCourt()">A√±adir</button>
            </div>


            <div id="courtList"></div>
            <button class="btn btn-gen" onclick="generateTournament()">GENERAR FIXTURE COMPLETO</button>
            <button class="btn btn-warning" 
                onclick="regenerateFutureMatches()"
                style="width:100%; margin-bottom:15px">
                üîÑ REGENERAR FIXTURE NO DISPUTADO
            </button>

        </div>

        <div id="fixture" class="card">
            <h3>Cronograma de Partidos</h3>
            <div id="fixtureContent"></div>
        </div>

        <div id="posiciones" class="card">
            <h3>Ranking Individual</h3>
            <div id="rankingContent"></div>
        </div>

        <div id="admin" class="card">
            <h3>Panel Admin</h3>
            <div id="adminLoginSection">
                <input type="password" id="adminPass" placeholder="Clave admin">
                <button class="btn btn-add" style="width:100%; margin-top:10px" id="loginBtn"
                    onclick="loginAdmin()">Ingresar</button>
            </div>
            <button class="btn btn-danger" id="logoutBtn"
                style="width:100%; margin-top:10px"
                onclick="logoutAdmin()">
                Cerrar sesi√≥n
            </button>

            <div id="adminStatus" style="margin-top:15px; font-weight:bold;"></div>
        </div>

    </div>

    <script>
document.addEventListener("DOMContentLoaded", () => {

    const savedAdmin = localStorage.getItem("isAdmin");

    if (savedAdmin === "true") {
        window.isAdmin = true;
        document.getElementById("adminStatus").innerText =
            "Modo Admin Activo ‚úÖ";
    }

     updateAdminUI();
    applyAdminRestrictions();
});

function updateAdminUI() {

    const loginSection = document.getElementById("adminLoginSection");
    const logoutBtn = document.getElementById("logoutBtn");
    const logintBtn = document.getElementById("loginBtn");
    const status = document.getElementById("adminStatus");
    const bulkSection = document.getElementById("bulkSection");

    if (!loginSection || !logoutBtn || !status ||!loginBtn) return;

    if (window.isAdmin) {

        loginSection.style.display = "none";
        loginBtn.style.display = "none";
        logoutBtn.style.display = "block";
        status.innerText = "Modo Admin Activo ‚úÖ";

        if (bulkSection)
            bulkSection.style.display = "block";

    } else {

        loginSection.style.display = "block";
        logoutBtn.style.display = "none";
        loginBtn.style.display = "block";
        status.innerText = "Modo P√∫blico";

        if (bulkSection)
            bulkSection.style.display = "none";
    }
}


function logoutAdmin() {

    window.isAdmin = false;
    localStorage.removeItem("isAdmin");

    renderPlayers();
    renderCourts();
    updateAdminUI();
    applyAdminRestrictions();


    openTab(null, "jugadores");

}

function loginAdmin() {

    const pass = document.getElementById("adminPass").value;
    const ADMIN_PASSWORD = "padelsanse";

    if (pass === ADMIN_PASSWORD) {

        window.isAdmin = true;
        localStorage.setItem("isAdmin", "true");

        renderPlayers();
        renderCourts();
        updateAdminUI();
        applyAdminRestrictions();


    } else {
        alert("Clave incorrecta");
    }

    document.getElementById("adminPass").value = "";
}



function applyAdminRestrictions() {

    const adminButtons = document.querySelectorAll(
        ".btn-warning, .btn-danger, .btn-gen"
    );

    adminButtons.forEach(btn => {
        btn.style.display = window.isAdmin ? "block" : "none";
    });

     // üîπ Inputs de jugadores
    const playerInputs = document.querySelectorAll(
        "#playerList input, #playerList button"
    );

    playerInputs.forEach(el => {
        el.disabled = !window.isAdmin;
        if (!window.isAdmin)
            el.style.opacity = 0.6;
        else
            el.style.opacity = 1;
    });

    // üîπ Inputs de canchas
    const courtSection = document.getElementById("canchas");
    if (courtSection) {
        const elements = courtSection.querySelectorAll(
            "input, button"
        );

        elements.forEach(el => {
            if (!el.classList.contains("score-input")) {
                el.disabled = !window.isAdmin;
                el.style.opacity = window.isAdmin ? 1 : 0.6;
            }
        });
    }
    
}


function save() {
    saveToFirebase(players, courts, matches);
}

        function openTab(evt, name) {
            document.querySelectorAll('.card').forEach(c => c.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(name).classList.add('active');
            if(evt) evt.currentTarget.classList.add('active');
            if(name === 'posiciones') calculateRanking();
            if(name === 'fixture') renderFixture();
        }

function normalizeTime(input, defaultValue) {

    if (!input) return defaultValue;

    input = input.trim();

    // Si viene solo la hora (ej: "18")
    if (/^\d{1,2}$/.test(input)) {
        const hour = input.padStart(2, '0');
        return `${hour}:00`;
    }

    // Si viene formato HH:MM
    if (/^\d{1,2}:\d{2}$/.test(input)) {
        const [h, m] = input.split(':');
        return `${h.padStart(2, '0')}:${m}`;
    }

    // Si no es v√°lido, devolver default
    return defaultValue;
}

        
     function importPlayers() {

         if (!window.isAdmin) return;

    const lines = document.getElementById('bulkPlayers').value.split('\n');

    lines.forEach(line => {
        const parts = line.split(',');
        if(parts.length >= 2) {
   

        const name = parts[0]?.trim();
        const cat = parseInt(parts[1]?.trim());

        const start = normalizeTime(parts[2], "19:00");
        const end   = normalizeTime(parts[3], "23:00");
            
            if(name && !isNaN(cat)) {
                
                players.push({ 
                    id: Math.random().toString(36).substr(2, 9), 
                    name,
                    cat,
                    startTime: start,
                    endTime: end,
                    matchesPlayed: 0,
                    lastTurn: -1,
                    historyPartners: new Set(),
                    historyRivals: new Set()
                });

            }
        }
    });

    document.getElementById('bulkPlayers').value = '';
    save(); 
    renderPlayers();
}



function renderPlayers() {

    document.getElementById('pCount').innerText = players.length;

    // Creamos copia con √≠ndice original
    const sortedPlayers = players
        .map((p, i) => ({ ...p, originalIndex: i }))
        .sort((a, b) => {

            // Primero categor√≠a
            if (a.cat !== b.cat)
                return a.cat - b.cat;

            // Luego nombre
            return a.name
                .toLowerCase()
                .localeCompare(b.name.toLowerCase());
        });

    document.getElementById('playerList').innerHTML =
    sortedPlayers.map(p => `
        <div class="player-list-item">
            
            <div>
                <strong>${p.name}</strong>
                <span style="color:#64748b;">Cat ${p.cat}¬∞</span>
            </div>

            <div style="margin-top:8px;">
                <small>Ingreso</small>
                <input type="time"
                    value="${p.startTime || '18:00'}"
                    ${!window.isAdmin ? 'disabled' : ''}
                    onchange="updateStartTime(${p.originalIndex}, this.value)">
            </div>

            <div style="margin-top:8px;">
                <small>Salida</small>
                <input type="time"
                    value="${p.endTime || '23:59'}"
                    ${!window.isAdmin ? 'disabled' : ''}
                    onchange="updateEndTime(${p.originalIndex}, this.value)">
            </div>

           ${window.isAdmin ? `
                <button onclick="removePlayer(${p.originalIndex})"
                    style="color:#dc2626;border:none;cursor:pointer;">
                    Eliminar jugador
                </button>
            ` : ``}

        </div>
    `).join('');

}




function updateStartTime(i, value) {
    players[i].startTime = value;
    save();
}

function updateEndTime(i, value) {
    players[i].endTime = value;
    save();
}

        function removePlayer(i) { 
        if (!window.isAdmin) return;

            players.splice(i, 1); 
            save(); 
            renderPlayers(); 
                                 }


        // --- NUEVAS FUNCIONES DE LIMPIEZA ---
        function resetFixtureOnly() {
            if (!window.isAdmin) return;

            if(confirm("¬øQuieres borrar solo el fixture? Mantendr√°s la lista de jugadores intacta para volver a sortear.")) {
                matches = [];
                save();
                renderFixture();
                alert("Fixture borrado. Puedes ir a la solapa de Canchas y generarlo de nuevo.");
            }
        }

        function resetAllPlayersAndMatches() {
            if (!window.isAdmin) return;

            if(confirm("ATENCI√ìN: Se borrar√°n todos los jugadores y el fixture actual. ¬øDeseas continuar?")) {
                players = [];
                matches = [];
                save();
                renderPlayers();
                renderFixture();
            }
        }

        // --- L√ìGICA DE CANCHAS ---
        function addCourt() {

            if (!window.isAdmin) return;

            const name = document.getElementById('cName').value;
            const time = document.getElementById('cTime').value;
            if(name && time) {
                courts.push({ id: Date.now(), name, startTime: time });
                save(); renderCourts();
            }
        }

        function renderCourts() {
            document.getElementById('courtList').innerHTML = courts.map((c, i) => `
                <div class="player-list-item">
                    <span><span class="badge bg-cancha">${c.name}</span> Inicio: ${c.startTime} hs</span>
                        ${window.isAdmin ? `
                             <button onclick="removeCourt(${i})"
                                style="color:#dc2626;border:none;cursor:pointer;">
                                Eliminar Reserva
                            </button>
                        ` : ``}
                </div>
            `).join('');
        }
        function removeCourt(i) { 
            if (!window.isAdmin) return;

                courts.splice(i,1); 
            save(); 
            renderCourts(); 
        }

  function generateTournament(startFromTime = 0, isRegeneration = false) {

    if (!window.isAdmin) {
        alert("Solo admin puede generar fixture");
        return;
    }

    normalizePlayers(); // üëà AGREGAR ESTO

    console.log("=== GENERANDO TORNEO ===");

    const timeline = generateTimelineV2(); // Debe devolver array con:
    // { time, court, timeMins, sortKey }

    for (let slot of timeline) {

        if (slot.sortKey <= startFromTime)
            continue;

        console.log("Evaluando slot:", slot.time, slot.court);

        // 1Ô∏è‚É£ Filtrar jugadores disponibles en este horario
        let disponibles = players.filter(p => {

            if (p.endTime) {
                const [eh, em] = p.endTime.split(':').map(Number);
                const endMins = eh * 60 + em;
                if (slot.timeMins > endMins)
                    return false;
            }

            if (p.startTime) {
                const [sh, sm] = p.startTime.split(':').map(Number);
                const startMins = sh * 60 + sm;
                if (slot.timeMins < startMins)
                    return false;
            }

            return true;
        });

        // IDs ya asignados en este mismo horario (mismo sortKey)
        const ocupadosEnEsteTurno = new Set(
            matches
                .filter(m => m.sortKey === slot.sortKey)
                .flatMap(m => [...m.t1, ...m.t2])
        );
        
        // Excluirlos de disponibles
        disponibles = disponibles.filter(p => !ocupadosEnEsteTurno.has(p.id));
        
                
        if (disponibles.length < 4) {
            console.log("No hay suficientes jugadores.");
            continue;
        }

        // 2Ô∏è‚É£ ORDEN INTELIGENTE POR RATIO REAL
        disponibles.sort((a, b) => {

            function calcularRatio(jugador) {

                let ingresoMins = 0;

                if (jugador.startTime) {
                    let [h, m] = jugador.startTime.split(':').map(Number);
                    ingresoMins = h * 60 + m;
                }

                // Contar horarios √∫nicos, no canchas
                const horariosUnicos = new Set(
                    timeline
                        .filter(t =>
                            t.timeMins >= ingresoMins &&
                            t.timeMins <= slot.timeMins
                        )
                        .map(t => t.timeMins)
                );
                
                let turnosDisponibles = horariosUnicos.size;

                if (turnosDisponibles === 0) return 0;

                return jugador.matchesPlayed / turnosDisponibles;
            }

            const ratioA = calcularRatio(a);
            const ratioB = calcularRatio(b);

            if (ratioA !== ratioB)
                return ratioA - ratioB;

            return a.lastTurn - b.lastTurn;
        });

        let match = findValidMatchPRO2(disponibles);
        
        if (!match) {
            console.log("No se pudo armar partido √∫nico, intentando permitir repeticiones...");
            match = findValidMatchPRO2(disponibles, true); // üí° permitir repetir
        }
        
        if (!match) {
            console.log("Aun con repeticiones no hay suficientes jugadores.");
            continue;
        }

    

        const newMatch = {
            id: matches.length + 1,
            t1: match.team1.map(p => p.id),
            t2: match.team2.map(p => p.id),
            time: slot.time,
            court: slot.court,
            sortKey: slot.sortKey,
            s1: null,
            s2: null
        };

        matches.push(newMatch);

        // 3Ô∏è‚É£ Actualizar estad√≠sticas
        [...match.team1, ...match.team2].forEach(p => {

            p.matchesPlayed++;
            p.lastTurn = slot.sortKey;

        });

        // 4Ô∏è‚É£ Guardar historial
        registerHistory(
            match.team1.map(p => p.id),
            match.team2.map(p => p.id)
        );

        console.log("Partido generado:", newMatch.id);
    }

    save();
}


function findValidMatch(playersList) {

    for (let i = 0; i < playersList.length; i++) {
        for (let j = i + 1; j < playersList.length; j++) {

            const p1 = playersList[i];
            const p2 = playersList[j];

            if (p1.historyPartners.has(p2.id))
                continue;

            for (let k = 0; k < playersList.length; k++) {
                for (let l = k + 1; l < playersList.length; l++) {

                    const p3 = playersList[k];
                    const p4 = playersList[l];

                    if (
                        p1.id === p3.id ||
                        p1.id === p4.id ||
                        p2.id === p3.id ||
                        p2.id === p4.id
                    )
                        continue;

                    if (p3.historyPartners.has(p4.id))
                        continue;

                    const conflicto =
                        p1.historyRivals.has(p3.id) ||
                        p1.historyRivals.has(p4.id) ||
                        p2.historyRivals.has(p3.id) ||
                        p2.historyRivals.has(p4.id);

                    if (conflicto)
                        continue;

                    return {
                        team1: [p1, p2],
                        team2: [p3, p4]
                    };
                }
            }
        }
    }

    return null;
}

function findValidMatchV2(playersList) {

    // Ordenamos por categor√≠a para favorecer combinaciones cercanas
    const list = [...playersList].sort((a, b) => a.cat - b.cat);

    // Funci√≥n que eval√∫a si un partido es v√°lido
    function isValid(p1, p2, p3, p4) {

        // Ya fueron compa√±eros
        if (p1.historyPartners.has(p2.id)) return false;
        if (p3.historyPartners.has(p4.id)) return false;

        // Ya fueron rivales
        const conflicto =
            p1.historyRivals.has(p3.id) ||
            p1.historyRivals.has(p4.id) ||
            p2.historyRivals.has(p3.id) ||
            p2.historyRivals.has(p4.id);

        if (conflicto) return false;

        return true;
    }

    // -------- PASADA 1: PRIORIDAD EQUIPOS BALANCEADOS --------
    for (let i = 0; i < list.length; i++) {
        for (let j = i + 1; j < list.length; j++) {

            const p1 = list[i];
            const p2 = list[j];

            // üî• Prioridad: diferencia de categor√≠a 1
            if (Math.abs(p1.cat - p2.cat) !== 1)
                continue;

            for (let k = 0; k < list.length; k++) {
                for (let l = k + 1; l < list.length; l++) {

                    const p3 = list[k];
                    const p4 = list[l];

                    // Evitar repetir jugador
                    if (
                        p1.id === p3.id ||
                        p1.id === p4.id ||
                        p2.id === p3.id ||
                        p2.id === p4.id
                    ) continue;

                    // Tambi√©n balanceado segundo equipo
                    if (Math.abs(p3.cat - p4.cat) !== 1)
                        continue;

                    if (isValid(p1, p2, p3, p4)) {
                        return {
                            team1: [p1, p2],
                            team2: [p3, p4]
                        };
                    }
                }
            }
        }
    }

    // -------- PASADA 2: CUALQUIER COMBINACI√ìN V√ÅLIDA --------
    for (let i = 0; i < list.length; i++) {
        for (let j = i + 1; j < list.length; j++) {

            const p1 = list[i];
            const p2 = list[j];

            for (let k = 0; k < list.length; k++) {
                for (let l = k + 1; l < list.length; l++) {

                    const p3 = list[k];
                    const p4 = list[l];

                    if (
                        p1.id === p3.id ||
                        p1.id === p4.id ||
                        p2.id === p3.id ||
                        p2.id === p4.id
                    ) continue;

                    if (isValid(p1, p2, p3, p4)) {
                        return {
                            team1: [p1, p2],
                            team2: [p3, p4]
                        };
                    }
                }
            }
        }
    }

    return null;
}

        function findValidMatchPRO(playersList) {

    const list = [...playersList];
    const matches = [];

    function scoreMatch(p1, p2, p3, p4) {
        let score = 0;

        // Prioridad balance 6-7
        if (Math.abs(p1.cat - p2.cat) === 1) score += 5;
        if (Math.abs(p3.cat - p4.cat) === 1) score += 5;

        // Penalizar repetir partner
        if (p1.historyPartners.has(p2.id)) score -= 10;
        if (p3.historyPartners.has(p4.id)) score -= 10;

        // Penalizar repetir rivales
        const rivalConflict =
            p1.historyRivals.has(p3.id) ||
            p1.historyRivals.has(p4.id) ||
            p2.historyRivals.has(p3.id) ||
            p2.historyRivals.has(p4.id);

        if (rivalConflict) score -= 5;

        return score;
    }

    for (let i = 0; i < list.length; i++) {
        for (let j = i + 1; j < list.length; j++) {
            for (let k = j + 1; k < list.length; k++) {
                for (let l = k + 1; l < list.length; l++) {

                    const players = [list[i], list[j], list[k], list[l]];

                    // Todas las formas posibles de armar 2 equipos
                    const teamOptions = [
                        [[0,1],[2,3]],
                        [[0,2],[1,3]],
                        [[0,3],[1,2]]
                    ];

                    for (let opt of teamOptions) {

                        const p1 = players[opt[0][0]];
                        const p2 = players[opt[0][1]];
                        const p3 = players[opt[1][0]];
                        const p4 = players[opt[1][1]];

                        const score = scoreMatch(p1,p2,p3,p4);

                        matches.push({
                            team1: [p1,p2],
                            team2: [p3,p4],
                            score
                        });
                    }
                }
            }
        }
    }

    if (matches.length === 0) return null;

    // Ordenar por mejor score
    matches.sort((a,b) => b.score - a.score);

    return matches[0];
}

function findValidMatchPRO2(playersList, allowRepetition = false) {

    const list = [...playersList];
    const matches = [];

    function scoreMatch(p1, p2, p3, p4) {
        let score = 0;

        if (Math.abs(p1.cat - p2.cat) === 1) score += 5;
        if (Math.abs(p3.cat - p4.cat) === 1) score += 5;

        if (!allowRepetition) {
            if (p1.historyPartners.has(p2.id)) score -= 10;
            if (p3.historyPartners.has(p4.id)) score -= 10;
    
            const rivalConflict =
                p1.historyRivals.has(p3.id) ||
                p1.historyRivals.has(p4.id) ||
                p2.historyRivals.has(p3.id) ||
                p2.historyRivals.has(p4.id);
    
            if (rivalConflict) score -= 5;
        }

        return score;
    }

    // Generar combinaciones como antes
    for (let i = 0; i < list.length; i++) {
        for (let j = i + 1; j < list.length; j++) {
            for (let k = j + 1; k < list.length; k++) {
                for (let l = k + 1; l < list.length; l++) {

                    const players = [list[i], list[j], list[k], list[l]];

                    const teamOptions = [
                        [[0,1],[2,3]],
                        [[0,2],[1,3]],
                        [[0,3],[1,2]]
                    ];

                    for (let opt of teamOptions) {
                        const p1 = players[opt[0][0]];
                        const p2 = players[opt[0][1]];
                        const p3 = players[opt[1][0]];
                        const p4 = players[opt[1][1]];

                        const score = scoreMatch(p1,p2,p3,p4);

                        matches.push({
                            team1: [p1,p2],
                            team2: [p3,p4],
                            score
                        });
                    }
                }
            }
        }
    }

    if (matches.length === 0) return null;

    // Ordenar por mejor score
    matches.sort((a,b) => b.score - a.score);

    return matches[0];
}
        
function registerHistory(team1Ids, team2Ids) {

    const realTeam1 = team1Ids.map(id => players.find(x => x.id === id));
    const realTeam2 = team2Ids.map(id => players.find(x => x.id === id));

    if (realTeam1.includes(undefined) || realTeam2.includes(undefined)) {
        console.error("Jugador no encontrado en players");
        return;
    }

    // Compa√±eros
    realTeam1[0].historyPartners.add(realTeam1[1].id);
    realTeam1[1].historyPartners.add(realTeam1[0].id);

    realTeam2[0].historyPartners.add(realTeam2[1].id);
    realTeam2[1].historyPartners.add(realTeam2[0].id);

    // Rivales
    for (let a of realTeam1) {
        for (let b of realTeam2) {
            a.historyRivals.add(b.id);
            b.historyRivals.add(a.id);
        }
    }
}


function normalizePlayers() {

    players.forEach(p => {


        if (!(p.historyPartners instanceof Set)) {
            p.historyPartners = new Set(p.historyPartners || []);
        }
        
        if (!(p.historyRivals instanceof Set)) {
            p.historyRivals = new Set(p.historyRivals || []);
        }


        // ---- stats ----
        if (typeof p.matchesPlayed !== "number")
            p.matchesPlayed = 0;

        if (typeof p.lastTurn !== "number")
            p.lastTurn = -1;
    });
}

        
function regenerateFutureMatches() {

    if (!window.isAdmin) {
        alert("Solo admin puede regenerar partidos");
        return;
    }

    normalizePlayers(); // üëà AGREGAR ESTO

    if (!confirm("Se recalcular√°n SOLO los partidos no jugados respetando historial. ¬øContinuar?"))
        return;

    const playedMatches =
        matches.filter(m => m.s1 !== null && m.s2 !== null);

    const pendingMatches =
        matches.filter(m => m.s1 === null && m.s2 === null);

    if (pendingMatches.length === 0) {
        alert("No hay partidos pendientes.");
        return;
    }

    let startFromTime = 0;

    if (playedMatches.length > 0) {
        const lastPlayed = playedMatches[playedMatches.length - 1];
        startFromTime = lastPlayed.sortKey;
    }

    matches = [...playedMatches];

    // RESET TOTAL
    players.forEach(p => {
        p.matchesPlayed = 0;
        p.lastTurn = -1;
        p.historyPartners = new Set();
        p.historyRivals = new Set();
    });

    // RECONSTRUIR DESDE HISTORIAL REAL
    playedMatches.forEach(m => {

        const team1 = m.t1;
        const team2 = m.t2;

        registerHistory(team1, team2);

        [...team1, ...team2].forEach(p => {

            const player = players.find(x => x.id === p.id);

            if (player) {
                player.matchesPlayed++;
                player.lastTurn = m.sortKey;
            }

        });
    });

    console.log("Historial reconstruido correctamente");

    generateTournament(startFromTime, true);

    save();
}






function deleteMatch(index) {

    const m = matches[index];

    if (m.s1 !== null && m.s2 !== null) {
        alert("No se puede borrar un partido ya jugado.");
        return;
    }

    matches.splice(index, 1);
    save();
    renderFixture();
}

function generateTimelineV2(slotMinutes = 15) {
    const timeline = [];

    for (let court of courts) {
        const [h, m] = court.startTime.split(':').map(Number);
        let startMins = h*60 + m;
        const endMins = startMins + 60; // 1 hora de duraci√≥n

        while (startMins < endMins) { // <-- importante: que incluya √∫ltimo slot
            const hours = Math.floor(startMins / 60);
            const minutes = startMins % 60;

            timeline.push({
                time: `${hours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}`,
                court: court.name,
                timeMins: startMins,
                sortKey: startMins
            });

            startMins += slotMinutes;
        }
    }

    return timeline;
}
        
function generateTimeline() {

    const timeline = [];

    courts.forEach(c => {

        const [h, m] = c.startTime.split(':').map(Number);
        const baseMins = h * 60 + m;

        // 3 partidos de 15' dentro de la reserva de 60'
        for (let i = 0; i < 3; i++) {

            const slotMins = baseMins + (i * 15);

            const hour = Math.floor(slotMins / 60);
            const mins = slotMins % 60;

            const timeStr =
                String(hour).padStart(2, '0') + ":" +
                String(mins).padStart(2, '0');

            timeline.push({
                courtId: c.id,
                court: c.name,
                time: timeStr,
                timeMins: slotMins,
                sortKey: slotMins
            });
        }
    });

    return timeline.sort((a, b) => a.sortKey - b.sortKey);
}

 function getPlayer(id) {
            return players.find(p => p.id === id);
        }

function renderFixture() {
    const container = document.getElementById('fixtureContent');

    if(matches.length === 0) { 
        container.innerHTML = "<p style='text-align:center; color:#94a3b8;'>No hay partidos generados. Ve a 'Canchas' y presiona el bot√≥n verde.</p>"; 
        return; 
    }

    // üîπ Ordenamos por horario y cancha para que no haya confusi√≥n
    const sortedMatches = [...matches].sort((a, b) => {
        // Primero por hora
        if(a.time !== b.time) {
            return a.time.localeCompare(b.time);
        }
        // Luego por cancha
        return a.court.localeCompare(b.court);
    });

    container.innerHTML = sortedMatches.map((m, idx) => `
        <div class="match-card">
            <div class="match-header">
                <span>PARTIDO #${m.id}</span>
                <span>
                    <span class="badge bg-hora">${m.time} HS</span> 
                    <span class="badge bg-cancha">${m.court}</span>
                </span>
            </div>

            <div class="match-body">
                <div>
                    <strong>
                        ${getPlayer(m.t1[0]).name} (${getPlayer(m.t1[0]).cat})<br>
                        ${getPlayer(m.t1[1]).name} (${getPlayer(m.t1[1]).cat})
                    </strong>
                </div>

                <div>
                    <input type="number" class="score-input" 
                        value="${m.s1 !== null ? m.s1 : ''}" 
                        onchange="updateScore(${idx}, 1, this.value)">
                    <input type="number" class="score-input" 
                        value="${m.s2 !== null ? m.s2 : ''}" 
                        onchange="updateScore(${idx}, 2, this.value)">
                </div>

                <div>
                    <strong>
                        ${getPlayer(m.t2[0]).name} (${getPlayer(m.t2[0]).cat})<br>
                        ${getPlayer(m.t2[1]).name} (${getPlayer(m.t2[1]).cat})
                    </strong>
                </div>
            </div>
        </div>
    `).join('');
}


function renderFixtureOld() {
            const container = document.getElementById('fixtureContent');
            if(matches.length === 0) { container.innerHTML = "<p style='text-align:center; color:#94a3b8;'>No hay partidos generados. Ve a 'Canchas' y presiona el bot√≥n verde.</p>"; return; }
            container.innerHTML = matches.map((m, idx) => `
                <div class="match-card">
                    <div class="match-header">
                        <span>PARTIDO #${m.id}</span>
                        <span><span class="badge bg-hora">${m.time} HS</span> <span class="badge bg-cancha">${m.court}</span></span>
                    </div>
                    <div class="match-body">
                        
                        <div>
                          <strong>
                            ${getPlayer(m.t1[0]).name} (${getPlayer(m.t1[0]).cat})<br>
                            ${getPlayer(m.t1[1]).name} (${getPlayer(m.t1[1]).cat})
                          </strong>
                        </div>

                        <div>
                            <input type="number" class="score-input" value="${m.s1 !== null ? m.s1 : ''}" onchange="updateScore(${idx}, 1, this.value)">
                            <input type="number" class="score-input" value="${m.s2 !== null ? m.s2 : ''}" onchange="updateScore(${idx}, 2, this.value)">
                        </div>

                        <div>
                          <strong>
                            ${getPlayer(m.t2[0]).name} (${getPlayer(m.t2[0]).cat})<br>
                            ${getPlayer(m.t2[1]).name} (${getPlayer(m.t2[1]).cat})
                          </strong>
                        </div>

                    </div>
                </div>
            `).join('');
        }

        function updateScore(idx, team, val) {
            const v = val === "" ? null : parseInt(val);
            if(team === 1) matches[idx].s1 = v; else matches[idx].s2 = v;
            save();
        }

        function calculateRanking() {

    let s = {};

    // Inicializar tabla
    players.forEach(p => {
        s[p.id] = {
            name: p.name,
            scheduled: 0,
            wins: 0,
            games: 0,
            played: 0
        };
    });

    const scheduledCount = calculateScheduledMatches(matches);

    Object.keys(scheduledCount).forEach(id => {
        if (s[id]) s[id].scheduled = scheduledCount[id];
        });

    matches.forEach(m => {

        if (m.s1 === null || m.s2 === null)
            return;

        // Partidos jugados
        [...m.t1, ...m.t2].forEach(id => {
            if (s[id]) s[id].played++;
        });

        // Games
        m.t1.forEach(id => {
            if (s[id]) s[id].games += m.s1;
        });

        m.t2.forEach(id => {
            if (s[id]) s[id].games += m.s2;
        });

        // Wins
        if (m.s1 > m.s2) {
            m.t1.forEach(id => {
                if (s[id]) s[id].wins++;
            });
        } else if (m.s2 > m.s1) {
            m.t2.forEach(id => {
                if (s[id]) s[id].wins++;
            });
        }

    });

    const sorted = Object.values(s).sort((a, b) =>
        b.wins - a.wins ||
        (b.played ? b.wins / b.played : 0) - (a.played ? a.wins / a.played : 0) ||
        b.games - a.games
    );

    document.getElementById('rankingContent').innerHTML =
        sorted.map((p, i) => `
            <div class="player-list-item">
                <span><strong>${i + 1}. ${p.name} (${p.scheduled})</strong></span>
                <span>${p.wins} G | ${p.games} Pts | ${p.played} PJ</span>
            </div>
        `).join('');
}

function calculateScheduledMatches(matches) {

    const count = {};

    matches.forEach(match => {

        [...match.t1, ...match.t2].forEach(player => {

            if (!count[player])
                count[player] = 0;

            count[player]++;

        });
    });

    return count;
}

        renderPlayers(); renderCourts(); renderFixture(); updateAdminUI(); applyAdminRestrictions();


     

    </script>
</body>
</html>
